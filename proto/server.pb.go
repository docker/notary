// Code generated by protoc-gen-go.
// source: proto/server.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	proto/server.proto
	proto/signer.proto

It has these top-level messages:
	Token
	Updates
	RepoRole
	Repository
	AuthResponse
	KeyResponse
	UpdateResponse
	KeyInfo
	KeyID
	Algorithm
	PublicKey
	Signature
	SignatureRequest
	Void
	HealthStatus
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Token holds a JWT that the Notary server will check for permissions
type Token struct {
	Jwt []byte `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
}

func (m *Token) Reset()                    { *m = Token{} }
func (m *Token) String() string            { return proto1.CompactTextString(m) }
func (*Token) ProtoMessage()               {}
func (*Token) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Updates struct {
	Jwt  []byte      `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	Gun  string      `protobuf:"bytes,2,opt,name=gun" json:"gun,omitempty"`
	Repo *Repository `protobuf:"bytes,3,opt,name=repo" json:"repo,omitempty"`
}

func (m *Updates) Reset()                    { *m = Updates{} }
func (m *Updates) String() string            { return proto1.CompactTextString(m) }
func (*Updates) ProtoMessage()               {}
func (*Updates) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Updates) GetRepo() *Repository {
	if m != nil {
		return m.Repo
	}
	return nil
}

type RepoRole struct {
	Jwt  []byte `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
	Gun  string `protobuf:"bytes,2,opt,name=gun" json:"gun,omitempty"`
	Role string `protobuf:"bytes,3,opt,name=role" json:"role,omitempty"`
}

func (m *RepoRole) Reset()                    { *m = RepoRole{} }
func (m *RepoRole) String() string            { return proto1.CompactTextString(m) }
func (*RepoRole) ProtoMessage()               {}
func (*RepoRole) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Repository is a collection of TUF files
type Repository struct {
	Root      []byte            `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	Targets   map[string][]byte `protobuf:"bytes,2,rep,name=targets" json:"targets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Snapshot  []byte            `protobuf:"bytes,3,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	Timestamp []byte            `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *Repository) Reset()                    { *m = Repository{} }
func (m *Repository) String() string            { return proto1.CompactTextString(m) }
func (*Repository) ProtoMessage()               {}
func (*Repository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Repository) GetTargets() map[string][]byte {
	if m != nil {
		return m.Targets
	}
	return nil
}

type AuthResponse struct {
	Authed bool `protobuf:"varint,1,opt,name=authed" json:"authed,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto1.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// Key represents the public key bytes returned by a key request
type KeyResponse struct {
	Public []byte `protobuf:"bytes,2,opt,name=public,proto3" json:"public,omitempty"`
}

func (m *KeyResponse) Reset()                    { *m = KeyResponse{} }
func (m *KeyResponse) String() string            { return proto1.CompactTextString(m) }
func (*KeyResponse) ProtoMessage()               {}
func (*KeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// UpdateResponse simply indicates if the update was successful. The error
// should be checked for reasons for failure
type UpdateResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *UpdateResponse) Reset()                    { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string            { return proto1.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()               {}
func (*UpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func init() {
	proto1.RegisterType((*Token)(nil), "proto.Token")
	proto1.RegisterType((*Updates)(nil), "proto.Updates")
	proto1.RegisterType((*RepoRole)(nil), "proto.RepoRole")
	proto1.RegisterType((*Repository)(nil), "proto.Repository")
	proto1.RegisterType((*AuthResponse)(nil), "proto.AuthResponse")
	proto1.RegisterType((*KeyResponse)(nil), "proto.KeyResponse")
	proto1.RegisterType((*UpdateResponse)(nil), "proto.UpdateResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Notary service

type NotaryClient interface {
	Auth(ctx context.Context, in *Token, opts ...grpc.CallOption) (*AuthResponse, error)
	Update(ctx context.Context, in *Updates, opts ...grpc.CallOption) (*UpdateResponse, error)
	Get(ctx context.Context, in *RepoRole, opts ...grpc.CallOption) (*Repository, error)
	GetKey(ctx context.Context, in *RepoRole, opts ...grpc.CallOption) (*KeyResponse, error)
}

type notaryClient struct {
	cc *grpc.ClientConn
}

func NewNotaryClient(cc *grpc.ClientConn) NotaryClient {
	return &notaryClient{cc}
}

func (c *notaryClient) Auth(ctx context.Context, in *Token, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/proto.Notary/Auth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notaryClient) Update(ctx context.Context, in *Updates, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := grpc.Invoke(ctx, "/proto.Notary/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notaryClient) Get(ctx context.Context, in *RepoRole, opts ...grpc.CallOption) (*Repository, error) {
	out := new(Repository)
	err := grpc.Invoke(ctx, "/proto.Notary/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notaryClient) GetKey(ctx context.Context, in *RepoRole, opts ...grpc.CallOption) (*KeyResponse, error) {
	out := new(KeyResponse)
	err := grpc.Invoke(ctx, "/proto.Notary/GetKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Notary service

type NotaryServer interface {
	Auth(context.Context, *Token) (*AuthResponse, error)
	Update(context.Context, *Updates) (*UpdateResponse, error)
	Get(context.Context, *RepoRole) (*Repository, error)
	GetKey(context.Context, *RepoRole) (*KeyResponse, error)
}

func RegisterNotaryServer(s *grpc.Server, srv NotaryServer) {
	s.RegisterService(&_Notary_serviceDesc, srv)
}

func _Notary_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(NotaryServer).Auth(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Notary_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Updates)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(NotaryServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Notary_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRole)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(NotaryServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Notary_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRole)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(NotaryServer).GetKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Notary_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Notary",
	HandlerType: (*NotaryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Auth",
			Handler:    _Notary_Auth_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Notary_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Notary_Get_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _Notary_GetKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 367 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x51, 0xcd, 0x4e, 0xea, 0x40,
	0x18, 0xa5, 0x14, 0x0a, 0xfd, 0xe8, 0x85, 0xcb, 0xdc, 0x7b, 0x93, 0xa6, 0xc9, 0x45, 0x9d, 0x95,
	0x09, 0x49, 0x89, 0xb8, 0x31, 0xee, 0x4c, 0x34, 0x2e, 0x4c, 0x5c, 0x10, 0x7c, 0x80, 0x02, 0x5f,
	0x00, 0x81, 0x4e, 0xd3, 0x99, 0x62, 0xfa, 0x36, 0x3e, 0x8d, 0xcf, 0xe5, 0xd7, 0x99, 0xaa, 0x25,
	0x18, 0x57, 0x93, 0x73, 0xe6, 0x9c, 0xf3, 0xfd, 0x01, 0x4b, 0x52, 0xa1, 0xc4, 0x48, 0x62, 0xba,
	0xc7, 0x34, 0xd4, 0x80, 0x35, 0xf5, 0xc3, 0xff, 0x42, 0x73, 0x2a, 0x36, 0x18, 0xb3, 0x0e, 0xd8,
	0xcf, 0x2f, 0xca, 0xb7, 0x4e, 0xad, 0x73, 0x8f, 0xdf, 0x42, 0xeb, 0x29, 0x59, 0x44, 0x0a, 0xe5,
	0x01, 0x5f, 0x80, 0x65, 0x16, 0xfb, 0x75, 0x02, 0x2e, 0x3b, 0x81, 0x46, 0x8a, 0x89, 0xf0, 0x6d,
	0x42, 0x9d, 0x71, 0xdf, 0xe4, 0x86, 0x13, 0xa2, 0xe4, 0x5a, 0x89, 0x34, 0xe7, 0x63, 0x68, 0x17,
	0x68, 0x22, 0xb6, 0xf8, 0x43, 0x8c, 0x47, 0x31, 0xa4, 0xd0, 0x31, 0x2e, 0x7f, 0xb5, 0x00, 0xbe,
	0x22, 0xcc, 0xa7, 0xf8, 0xf0, 0x8d, 0xa0, 0xa5, 0xa2, 0x74, 0x89, 0x4a, 0x92, 0xd7, 0xa6, 0xa2,
	0x83, 0xa3, 0xa2, 0xe1, 0xd4, 0x08, 0xee, 0x62, 0x45, 0xf6, 0xdf, 0xd0, 0x96, 0x71, 0x94, 0xc8,
	0x15, 0x45, 0xd8, 0x3a, 0xa2, 0x0f, 0xae, 0x5a, 0xef, 0x50, 0xaa, 0x68, 0x97, 0xf8, 0x8d, 0x82,
	0x0a, 0x42, 0xf0, 0x0e, 0x4c, 0xd4, 0xdd, 0x06, 0x73, 0x5d, 0xd2, 0x65, 0xbf, 0xa0, 0xb9, 0x8f,
	0xb6, 0x19, 0xea, 0x66, 0xbd, 0xeb, 0xfa, 0x95, 0xc5, 0x07, 0xe0, 0xdd, 0x64, 0x6a, 0x35, 0x41,
	0x99, 0x88, 0x58, 0x22, 0xeb, 0x82, 0x13, 0x11, 0xc6, 0x85, 0xb6, 0xb4, 0xf9, 0x7f, 0xe8, 0x3c,
	0x60, 0x5e, 0xfd, 0x4e, 0xb2, 0xd9, 0x76, 0x3d, 0x37, 0x11, 0xfc, 0x0c, 0xba, 0x66, 0xb7, 0x9f,
	0x8a, 0x1e, 0xb4, 0x64, 0x36, 0x9f, 0xa3, 0x94, 0x26, 0x61, 0xfc, 0x66, 0x81, 0xf3, 0x28, 0x68,
	0xd4, 0x9c, 0x0d, 0xa1, 0x51, 0x14, 0x63, 0x5e, 0x39, 0xa9, 0x3e, 0x56, 0xf0, 0xa7, 0x44, 0xd5,
	0x3e, 0x78, 0x8d, 0x5d, 0x80, 0x63, 0xa2, 0x59, 0xb7, 0x14, 0x94, 0x57, 0x0c, 0xfe, 0x1d, 0xe0,
	0x8a, 0x65, 0x08, 0xf6, 0x3d, 0x2a, 0xd6, 0xab, 0x2c, 0xb2, 0xb8, 0x57, 0xf0, 0xcd, 0x39, 0x6b,
	0xb4, 0x7f, 0x87, 0xc4, 0x34, 0xdc, 0xb1, 0x9e, 0x95, 0x44, 0x65, 0x72, 0x5e, 0x9b, 0x39, 0x9a,
	0xbc, 0x7c, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x84, 0x87, 0x9c, 0xdb, 0x81, 0x02, 0x00, 0x00,
}
